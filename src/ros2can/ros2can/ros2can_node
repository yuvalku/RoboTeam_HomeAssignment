import rclpy
from rclpy.node import Node
from interfaces.msg import WheelsVelocity, CanFrame
from utilities import can_bridge
from time import sleep

class Ros2Can(Node):
    def __init__(self):
        super().__init__('ros2can_node')
        self.ros2can_bridge_sub = self.create_subscription(
            WheelsVelocity, 'wheels_vel', self.ros2can_bridge_sub, 10)
        
        self.right_wheel_velocity = 0x00
        self.right_wheel_direction = 0x00
        self.left_wheel_velocity = 0x00
        self.left_wheel_direction = 0x00

    def ros2can_bridge_sub(self, msg: WheelsVelocity):
        if self.right_wheel_velocity != hex(msg.right_wheel_velocity) and self.left_wheel_velocity != hex(msg.left_wheel_velocity):
            self.right_wheel_velocity = hex(msg.right_wheel_velocity)
            self.right_wheel_direction = msg.right_wheel_direction
            self.left_wheel_velocity = hex(msg.left_wheel_velocity)
            self.left_wheel_direction = msg.left_wheel_direction
        
            can = can_bridge.CanBridge()
            left_motor_data = [0x01, self.left_wheel_velocity, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
            right_motor_data = [0x01, self.right_wheel_velocity, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
            if self.left_wheel_direction == -1:
                left_motor_data[2] = 0xff
            if self.right_wheel_direction == 1:
                right_motor_data[2] = 0xff
            
            left_motor_msg = can.generate_message(can_bridge.LEFT_MOTOR, left_motor_data)
            right_motor_msg = can.generate_message(can_bridge.LEFT_MOTOR, right_motor_data)
            can.send_message(left_motor_msg)
            can.send_message(right_motor_msg)

    
def main(args=None):
    rclpy.init(args=args)
    ros2can = Ros2Can()
    rclpy.spin(ros2can)
    ros2can.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()
